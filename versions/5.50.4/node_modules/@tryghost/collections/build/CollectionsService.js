"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectionsService = void 0;
const Collection_1 = require("./Collection");
class CollectionsService {
    collectionsRepository;
    constructor(deps) {
        this.collectionsRepository = deps.collectionsRepository;
    }
    toDTO(collection) {
        return {
            id: collection.id,
            title: collection.title || null,
            slug: collection.slug,
            description: collection.description || null,
            feature_image: collection.featureImage || null,
            type: collection.type,
            filter: collection.filter,
            created_at: collection.createdAt,
            updated_at: collection.updatedAt,
            posts: collection.posts.map((postId, index) => ({
                id: postId,
                sort_order: index
            }))
        };
    }
    fromDTO(data) {
        const mappedDTO = {
            title: data.title,
            slug: data.slug,
            description: data.description,
            featureImage: data.feature_image,
            filter: data.filter
        };
        // delete out keys that contain undefined values
        for (const key of Object.keys(mappedDTO)) {
            if (mappedDTO[key] === undefined) {
                delete mappedDTO[key];
            }
        }
        return mappedDTO;
    }
    async createCollection(data) {
        const collection = await Collection_1.Collection.create({
            title: data.title,
            slug: data.slug,
            description: data.description,
            type: data.type,
            filter: data.filter,
            featureImage: data.feature_image
        });
        await this.collectionsRepository.save(collection);
        return this.toDTO(collection);
    }
    async addPostToCollection(collectionId, post) {
        const collection = await this.collectionsRepository.getById(collectionId);
        if (!collection) {
            return null;
        }
        collection.addPost(post);
        this.collectionsRepository.save(collection);
        return this.toDTO(collection);
    }
    async edit(data) {
        const collection = await this.collectionsRepository.getById(data.id);
        if (!collection) {
            return null;
        }
        if (data.posts) {
            for (const post of data.posts) {
                collection.addPost(post);
            }
        }
        const collectionData = this.fromDTO(data);
        Object.assign(collection, collectionData);
        await this.collectionsRepository.save(collection);
        return this.toDTO(collection);
    }
    async getById(id) {
        return await this.collectionsRepository.getById(id);
    }
    async getAll(options) {
        const collections = await this.collectionsRepository.getAll(options);
        return {
            data: collections,
            meta: {
                pagination: {
                    page: 1,
                    pages: 1,
                    limit: collections.length,
                    total: collections.length,
                    prev: null,
                    next: null
                }
            }
        };
    }
    async destroy(id) {
        const collection = await this.getById(id);
        if (collection) {
            collection.deleted = true;
            await this.collectionsRepository.save(collection);
        }
        return collection;
    }
    async removePostFromCollection(id, postId) {
        const collection = await this.getById(id);
        if (!collection) {
            return null;
        }
        if (collection) {
            collection.removePost(postId);
            await this.collectionsRepository.save(collection);
        }
        return this.toDTO(collection);
    }
}
exports.CollectionsService = CollectionsService;
